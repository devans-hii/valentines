<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine Lock & Key</title>
  <style>
    :root{
      --glow: rgba(255,93,143,0.95);
      --bg-dark: #050006;
      --bg-mid: #0b0210;
      --bg-light: #250a20;
    }
    html,body{height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial;}
    body{
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100vh;
      background:
        radial-gradient(900px 360px at 10% 20%, rgba(255,80,140,0.06) 0%, transparent 10%),
        radial-gradient(700px 300px at 85% 80%, rgba(255,210,107,0.03) 0%, transparent 8%),
        linear-gradient(180deg, var(--bg-light) 0%, var(--bg-mid) 40%, var(--bg-dark) 100%);
      overflow:hidden;
    }

    /* subtle animated shine overlay */
    .shiny {
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:0;
      mix-blend-mode: screen;
      background:
        radial-gradient(500px 240px at 15% 10%, rgba(255,255,255,0.03), transparent 14%),
        radial-gradient(360px 180px at 80% 80%, rgba(255,255,255,0.02), transparent 10%);
      animation: shimmer 7s linear infinite;
      opacity:0.95;
    }
    @keyframes shimmer{
      0%{ transform: translateY(0) rotate(0deg) scale(1); }
      50%{ transform: translateY(-6px) rotate(.6deg) scale(1.02); }
      100%{ transform: translateY(0) rotate(0deg) scale(1); }
    }

    .stage{
      width:860px;
      max-width:96vw;
      height:700px;
      max-height:92vh;
      position:relative;
      user-select:none;
      touch-action:none;
      z-index:2;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .shrine{
      width:460px;
      height:460px;
      position:relative;
      z-index:10;
    }

    .heart-wrap{ width:100%; height:100%; position:relative; display:block; }

    svg.heart-svg{ width:100%; height:100%; display:block; z-index:5; }
    .heart-half{ transition: transform .9s cubic-bezier(.2,.9,.2,1), filter .3s; filter: drop-shadow(0 14px 36px rgba(0,0,0,0.5)); }
    .heart-left{ transform-origin:65% 30%; }
    .heart-right{ transform-origin:35% 30%; }

    .heart-open .heart-left{ transform:rotate(-26deg) translate(-8px,-10px); }
    .heart-open .heart-right{ transform:rotate(26deg) translate(8px,-10px); }

    .heart-content{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%) scale(.92);
      width:80%;
      height:60%;
      border-radius:16px;
      overflow:hidden;
      box-shadow:0 14px 40px rgba(0,0,0,0.6);
      opacity:0;
      transition:opacity .6s .25s, transform .7s;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:6;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));
    }
    .heart-content img{ width:100%; height:100%; object-fit:cover; display:block; }
    .heart-open .heart-content{ opacity:1; transform:translate(-50%,-50%) scale(1); }

    .message{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      bottom:16%;
      font-size:30px;
      color:#fff;
      opacity:0;
      transition:opacity .7s .4s, transform .7s .4s;
      text-shadow:0 8px 26px rgba(0,0,0,0.6);
      z-index:7;
    }
    .heart-open .message{ opacity:1; transform:translateX(-50%) translateY(0); }

    /* lock */
    .lock{
      position:absolute;
      width:120px;
      height:120px;
      left:50%;
      top:30%;
      transform:translateX(-50%);
      z-index:20;
      pointer-events:none;
    }
    .lock .body{ transition: fill .22s, filter .22s; }
    .lock.near .body{ filter: drop-shadow(0 0 30px var(--glow)); }
    .lock.near .shackle{ filter: drop-shadow(0 0 30px var(--glow)); }
    .lock.open .body{ fill:#2f2f2f; }
    .lock .shackle{ transform-origin:50% 75%; transition:transform .7s; }
    .lock.open .shackle{ transform:rotate(-50deg) translateY(-8px) translateX(-3px); }

    .slot-indicator{
      position:absolute;
      width:20px; height:14px;
      border-radius:5px;
      border:2px dashed rgba(255,255,255,0.10);
      transform:translate(-50%,-50%);
      pointer-events:none;
      opacity:0;
      transition:opacity .22s;
      z-index:21;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.05));
    }
    .lock.near ~ .slot-indicator{ opacity:1; border-color: rgba(255,93,143,0.95); box-shadow:0 0 30px var(--glow); }

    /* key positioned away from center (bottom-left) */
    .key{
      width:170px;
      height:120px;
      position:absolute;
      left:28px;
      top:0;
      z-index:40;
      touch-action:none;
      cursor:grab;
      transform-origin:42px 38px;
      user-select:none;
    }
    .key.dragging{ cursor:grabbing; }
    .key svg{ width:100%; height:100%; display:block; pointer-events:none; }

    .key.inserted{ transition:left .42s, top .42s, transform .6s; pointer-events:none; z-index:90; }
    .key.turning{ transition: transform .9s cubic-bezier(.2,.9,.2,1); }

    .hint{ position:absolute; left:50%; transform:translateX(-50%); bottom:8px; color:rgba(255,255,255,0.85); font-size:14px; z-index:40; }

    /* confetti canvas */
    #confettiCanvas{
      position:absolute;
      left:0; top:0;
      width:100%; height:100%;
      pointer-events:none;
      z-index:999;
    }

    /* small overlay shown when audio blocked */
    #playOverlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.45); z-index:9999; visibility:hidden; opacity:0; transition:opacity .25s; }
    #playOverlay.visible{ visibility:visible; opacity:1; } 
    #playOverlay button{ background:linear-gradient(90deg,#ff6fa3,#ffd36b); border:none; color:#111; padding:12px 20px; border-radius:10px; font-size:16px; cursor:pointer; box-shadow:0 8px 30px rgba(0,0,0,0.45); }

    @media (max-width:520px){
      .stage{ height:86vh; min-height:520px; }
      .shrine{ width:340px; height:340px; }
      .key{ width:140px; height:100px; left:18px; }
    }
  </style>
</head>
<body>
  <div class="shiny" aria-hidden="true"></div>

  <div class="stage" id="stage">
    <canvas id="confettiCanvas" aria-hidden="true"></canvas>

    <div class="shrine">
      <div class="heart-wrap" id="heartWrap">
        <!-- Heart halves (SVG) -->
        <svg class="heart-svg" viewBox="0 0 200 200" aria-hidden="true">
          <defs>
            <linearGradient id="g1" x1="0" x2="1"><stop offset="0" stop-color="#ff9bb7"/><stop offset="1" stop-color="#ff5d8f"/></linearGradient>
          </defs>

          <g class="heart-half heart-left">
            <path d="M100 34 C80 10, 32 14, 30 58 C28 100, 85 135, 100 153 Z" fill="url(#g1)" stroke="rgba(0,0,0,0.08)" stroke-width="1.2" />
          </g>
          <g class="heart-half heart-right">
            <path d="M100 34 C120 10, 168 14, 170 58 C172 100, 115 135, 100 153 Z" fill="url(#g1)" stroke="rgba(0,0,0,0.08)" stroke-width="1.2" />
          </g>
        </svg>

        <!-- Lock -->
        <div class="lock" id="lock" role="img" aria-label="locked heart">
          <svg viewBox="0 0 120 120" width="100%" height="100%" aria-hidden="true">
            <g class="shackle"><path d="M30 50 C30 26, 50 10, 60 10 C70 10, 90 26, 90 50 L90 60 L84 60 L84 50 C84 34, 70 22, 60 22 C50 22, 36 34, 36 50 L36 60 L30 60 Z" fill="#e9e9e9" stroke="#cfcfcf" stroke-width="1"/></g>
            <g transform="translate(12,48)"><rect class="body" id="lockBody" x="0" y="8" width="96" height="64" rx="10" ry="10" fill="#1f1f1f" stroke="#2b2b2b" /><rect x="40" y="28" width="16" height="10" rx="2" fill="#0b0b0b" /></g>
          </svg>
        </div>

        <div class="slot-indicator" id="slotIndicator" aria-hidden="true"></div>

        <!-- revealed content -->
        <div class="heart-content" id="heartContent" aria-hidden="true">
          <!-- Replace the src below with your image or local file -->
          <img id="revealImage" src="https://picsum.photos/900/600?blur=1" alt="valentine picture">
        </div>

        <div class="message" id="message">will u be my valentine</div>
      </div>
    </div>

    <div class="sparkle" id="sparkle" aria-hidden="true" style="position:absolute; left:50%; top:12%; transform:translateX(-50%); z-index:30;">
      <svg viewBox="0 0 24 24" width="20" height="20"><path d="M12 2 L13.5 9 L21 12 L13.5 15 L12 22 L10.5 15 L3 12 L10.5 9 Z" fill="#ffe7f0" opacity="0.95"/></svg>
    </div>

    <!-- Key (start bottom-left off-center) -->
    <div class="key" id="key" role="button" aria-label="drag key to unlock" tabindex="0">
      <svg viewBox="0 0 240 180" preserveAspectRatio="xMinYMin meet" aria-hidden="true">
        <g id="keyHead"><circle cx="56" cy="56" r="28" fill="#ffd76b" stroke="#b8862b" stroke-width="3" /><circle cx="56" cy="56" r="12" fill="#fff7ea" /></g>
        <rect x="80" y="48" width="100" height="16" rx="6" fill="#ffd76b" stroke="#b8862b" stroke-width="3"/>
        <rect x="176" y="46" width="12" height="8" fill="#b8862b"/>
        <rect x="176" y="60" width="12" height="8" fill="#b8862b"/>
      </svg>
    </div>

    <div class="hint">Drag the key to the lock</div>

    <!-- Audio: put song.mp3 next to this file or edit the src to a URL you control -->
    <audio id="english" src="english.mp3" preload="auto"></audio>
  </div>

  <!-- overlay if audio blocked -->
  <div id="playOverlay" aria-hidden="true">
    <button id="playBtn">Allow music</button>
  </div>

  <script>
    /*
      Single-file interaction:
      - Drag the key over the lock, when near it glows.
      - Releasing close-enough snaps and turns key, unlocks shackle, opens heart, plays song.
      - If audio is blocked, "Allow music" button is shown.
      - Confetti burst plays when unlocked.
    */

    (function(){
      const stage = document.getElementById('stage');
      const key = document.getElementById('key');
      const lock = document.getElementById('lock');
      const heartWrap = document.getElementById('heartWrap');
      const heartContent = document.getElementById('heartContent');
      const message = document.getElementById('message');
      const sparkle = document.getElementById('sparkle');
      const audio = document.getElementById('song');
      const slotIndicator = document.getElementById('slotIndicator');
      const playOverlay = document.getElementById('playOverlay');
      const playBtn = document.getElementById('playBtn');
      const confettiCanvas = document.getElementById('confettiCanvas');
      const ctx = confettiCanvas.getContext ? confettiCanvas.getContext('2d') : null;

      let dragging = false;
      let opened = false;
      let offset = {x:0,y:0};
      let near = false;
      let userGestureCaptured = false;

      // thresholds
      const nearThreshold = 110;
      const insertThreshold = 90;

      // key & lock viewbox geometry (assumptions based on SVGs above)
      const keyViewBox = { width:240, height:180, head:{cx:56, cy:56, r:28} };
      const lockViewBox = { width:120, height:120, slot:{ x:12+40, y:48+28, w:16, h:10 } };

      // --- layout helpers ---
      function resizeCanvas(){
        const rect = stage.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        confettiCanvas.width  = Math.max(1, Math.floor(w * devicePixelRatio));
        confettiCanvas.height = Math.max(1, Math.floor(h * devicePixelRatio));
        confettiCanvas.style.width  = w + 'px';
        confettiCanvas.style.height = h + 'px';
        if(ctx) ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      }

      function resetKey(){
        const rect = stage.getBoundingClientRect();
        const krect = key.getBoundingClientRect();
        const left = 28;
        const top = Math.round(rect.height - krect.height - 26);
        key.style.transition = 'none';
        key.style.left = left + 'px';
        key.style.top = top + 'px';
        key.style.transform = 'rotate(0deg)';
        key.getBoundingClientRect(); // force reflow
        requestAnimationFrame(()=> key.style.transition = '');
      }

      function toLocalPoint(clientX, clientY){
        const r = stage.getBoundingClientRect();
        return { x: clientX - r.left, y: clientY - r.top };
      }

      function getSlotCenterStage(){
        const lockRect = lock.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const scaleX = lockRect.width / lockViewBox.width;
        const scaleY = lockRect.height / lockViewBox.height;
        const slotCenterX = lockRect.left - stageRect.left + lockViewBox.slot.x * scaleX + (lockViewBox.slot.w * scaleX)/2;
        const slotCenterY = lockRect.top - stageRect.top + lockViewBox.slot.y * scaleY + (lockViewBox.slot.h * scaleY)/2;
        return { x: slotCenterX, y: slotCenterY, w: lockViewBox.slot.w * scaleX, h: lockViewBox.slot.h * scaleY };
      }

      function getKeyHeadStage(){
        const keyRect = key.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const scaleX = keyRect.width / keyViewBox.width;
        const scaleY = keyRect.height / keyViewBox.height;
        const headX = keyRect.left - stageRect.left + keyViewBox.head.cx * scaleX;
        const headY = keyRect.top - stageRect.top + keyViewBox.head.cy * scaleY;
        const headR = keyViewBox.head.r * Math.max(scaleX, scaleY);
        return { x: headX, y: headY, r: headR };
      }

      function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx + dy*dy); }

      function headOverlapsSlot(head, slot){
        const rectLeft = slot.x - slot.w/2;
        const rectTop  = slot.y - slot.h/2;
        const closestX = Math.max(rectLeft, Math.min(head.x, rectLeft + slot.w));
        const closestY = Math.max(rectTop, Math.min(head.y, rectTop + slot.h));
        const dx = head.x - closestX, dy = head.y - closestY;
        return (dx*dx + dy*dy) <= (head.r * head.r);
      }

      function checkProximityAndUpdate(head){
        const slot = getSlotCenterStage();
        const d = distance(head, slot);
        const isNear = d < nearThreshold;
        if(isNear && !near){ lock.classList.add('near'); near=true; }
        else if(!isNear && near){ lock.classList.remove('near'); near=false; }
        slotIndicator.style.left = slot.x + 'px';
        slotIndicator.style.top  = slot.y + 'px';
        slotIndicator.style.width = Math.max(12, Math.round(slot.w)) + 'px';
        slotIndicator.style.height = Math.max(8, Math.round(slot.h)) + 'px';
      }

      // Attempt to capture a user gesture so audio play later is allowed
      function tryCaptureUserGesture(){
        if(userGestureCaptured) return;
        userGestureCaptured = true;
        audio.play().then(()=>{ audio.pause(); audio.currentTime = 0; }).catch(()=>{ /* blocked, overlay will appear later */ });
      }

      function insertAndOpen(){
        if(opened) return;
        opened = true;
        lock.classList.remove('near');

        const slot = getSlotCenterStage();
        const head = getKeyHeadStage();
        const keyRect = key.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const headOffsetX = head.x - (keyRect.left - stageRect.left);
        const headOffsetY = head.y - (keyRect.top - stageRect.top);
        const targetLeft = Math.round(slot.x - headOffsetX);
        const targetTop  = Math.round(slot.y - headOffsetY);

        // snap key in
        key.classList.add('inserted');
        key.style.transition = 'left .42s cubic-bezier(.2,.9,.2,1), top .42s cubic-bezier(.2,.9,.2,1)';
        key.style.left = targetLeft + 'px';
        key.style.top = targetTop + 'px';

        key.addEventListener('transitionend', beginTurn, { once:true });

        function beginTurn(){
          // set transform origin to head location so rotation looks natural
          const keyRectNow = key.getBoundingClientRect();
          const originX = head.x - (keyRectNow.left - stage.getBoundingClientRect().left);
          const originY = head.y - (keyRectNow.top - stage.getBoundingClientRect().top);
          key.style.transformOrigin = `${originX}px ${originY}px`;
          requestAnimationFrame(()=>{ key.classList.add('turning'); key.style.transform = 'rotate(-115deg)'; });
          key.addEventListener('transitionend', finishOpen, { once:true });
        }

        function finishOpen(){
          lock.classList.add('open');
          heartWrap.classList.add('heart-open');
          heartContent.setAttribute('aria-hidden','false');

          // try to play audio; if blocked show overlay
          audio.play().then(()=> {
            hidePlayOverlay();
          }).catch(()=> {
            showPlayOverlay();
          });

          // confetti
          startConfetti();
        }
      }

      // Pointer handlers
      function onPointerDown(e){
        if(opened) return;
        tryCaptureUserGesture();
        dragging = true;
        key.classList.add('dragging');
        const local = toLocalPoint(e.clientX, e.clientY);
        const keyRect = key.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const keyLeft = keyRect.left - stageRect.left;
        const keyTop = keyRect.top - stageRect.top;
        offset.x = local.x - keyLeft;
        offset.y = local.y - keyTop;
        try{ key.setPointerCapture && key.setPointerCapture(e.pointerId); }catch(e){}
      }

      function onPointerMove(e){
        if(!dragging || opened) return;
        const local = toLocalPoint(e.clientX, e.clientY);
        const keyRect = key.getBoundingClientRect();
        const w = keyRect.width, h = keyRect.height;
        let x = local.x - offset.x;
        let y = local.y - offset.y;
        x = Math.max(0, Math.min(stage.clientWidth - w, x));
        y = Math.max(0, Math.min(stage.clientHeight - h, y));
        key.style.left = x + 'px';
        key.style.top = y + 'px';

        const head = getKeyHeadStage();
        checkProximityAndUpdate(head);
        if(near){
          const slot = getSlotCenterStage();
          sparkle.style.left = `${slot.x}px`;
          sparkle.style.top  = `${slot.y - 48}px`;
        }
      }

      function onPointerUp(e){
        if(!dragging) return;
        dragging = false;
        key.classList.remove('dragging');
        try{ key.releasePointerCapture && key.releasePointerCapture(e.pointerId); }catch(err){}
        const head = getKeyHeadStage();
        const slot = getSlotCenterStage();
        const d = distance(head, slot);
        const overlapped = headOverlapsSlot(head, slot);
        setTimeout(()=> lock.classList.remove('near'), 10);
        if(d < insertThreshold || overlapped){
          insertAndOpen();
        }else{
          resetKey();
        }
      }

      // audio overlay helpers
      function showPlayOverlay(){ playOverlay.classList.add('visible'); playOverlay.setAttribute('aria-hidden','false'); }
      function hidePlayOverlay(){ playOverlay.classList.remove('visible'); playOverlay.setAttribute('aria-hidden','true'); }

      playBtn.addEventListener('click', ()=> {
        audio.play().then(()=> { hidePlayOverlay(); }).catch(err=> { console.error('Playback blocked', err); });
      });

      // keyboard & click fallback
      key.addEventListener('keydown', (ev)=>{ if(opened) return; if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); tryCaptureUserGesture(); insertAndOpen(); }});
      key.addEventListener('click', ()=>{ if(!opened){ tryCaptureUserGesture(); insertAndOpen(); }});

      key.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('pointercancel', onPointerUp);

      window.addEventListener('resize', ()=>{ resizeCanvas(); resetKey(); });

      // --- Confetti implementation (canvas) ---
      let confettiSprites = [], confettiActive = false, confettiAnimId = null;
      const COLORS = ['#ff3b6b','#ff9bb7','#ffd36b','#ffd8a8','#8ce99a','#80d8ff','#c099ff'];

      function rand(min,max){ return Math.random()*(max-min)+min; }
      function createConfettiParticle(x,y){
        return {
          x, y,
          w: rand(6,14),
          h: rand(8,18),
          color: COLORS[Math.floor(Math.random()*COLORS.length)],
          vx: rand(-220,220) / 100,
          vy: rand(-6,-2),
          rot: rand(0,360),
          vr: rand(-8,8),
          life: rand(70,140),
          age: 0
        };
      }

      function startConfetti(){
        if(!ctx) return;
        resizeCanvas();
        confettiSprites = [];
        const slot = getSlotCenterStage();
        const count = 100;
        for(let i=0;i<count;i++){
          confettiSprites.push(createConfettiParticle(slot.x + rand(-36,36), slot.y + rand(-20,20)));
        }
        confettiActive = true;
        if(confettiAnimId) cancelAnimationFrame(confettiAnimId);
        confettiLoop();
        setTimeout(()=> confettiActive = false, 6500);
      }

      function confettiLoop(){
        if(!ctx) return;
        const rect = stage.getBoundingClientRect();
        ctx.clearRect(0,0,rect.width,rect.height);
        for(let p of confettiSprites){
          p.vy += 0.12;
          p.x += p.vx;
          p.y += p.vy;
          p.rot += p.vr;
          p.age++;
          const alpha = Math.max(0, 1 - p.age / p.life);
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot * Math.PI / 180);
          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
          ctx.restore();
        }
        if(confettiActive && confettiSprites.length < 400 && Math.random() < 0.35){
          const slot = getSlotCenterStage();
          confettiSprites.push(createConfettiParticle(slot.x + rand(-48,48), slot.y + rand(-20,20)));
        }
        confettiSprites = confettiSprites.filter(p => p.age < p.life);
        confettiAnimId = requestAnimationFrame(confettiLoop);
      }

      // audio error handler
      audio.addEventListener('error', ()=> { console.warn('Audio load/playback problem. Check song file path or console for details.'); showPlayOverlay(); });

      // init
      resizeCanvas();
      resetKey();
      audio.load();

      // helpful: expose a global unlock trigger for debugging (optional)
      window.__forceUnlock = function(){ tryCaptureUserGesture(); insertAndOpen(); };

    })();
  </script>
</body>
</html>
