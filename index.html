<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine Lock & Key</title>
  <style>
    :root{
      --bg:#111;
      --accent:#ff5d8f;
      --gold:#ffd26b;
      --lock:#222;
      --glow: rgba(255, 93, 143, 0.85);
    }
    html,body{height:100%;}
    body{
      margin:0;
      background: radial-gradient(ellipse at 10% 10%, #250a20 0%, #0b0210 40%, #050006 100%);
      color:#fff;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100vh;
      overflow:hidden;
    }

    .stage{
      width:760px;
      max-width:94vw;
      height:600px;
      max-height:86vh;
      position:relative;
      user-select:none;
      touch-action:none;
    }

    /* center area for heart+lock */
    .shrine{
      width:360px;
      height:360px;
      margin:0 auto;
      position:relative;
      top:20px;
    }

    /* Heart container */
    .heart-wrap{
      width:100%;
      height:100%;
      position:relative;
      display:block;
    }

    /* The inner content revealed when heart opens */
    .heart-content{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%) scale(0.9);
      width:84%;
      height:64%;
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6);
      opacity:0;
      transition: opacity 600ms ease 250ms, transform 700ms cubic-bezier(.2,.9,.2,1);
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(0,0,0,0.06));
      color:#111;
    }
    .heart-content img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .message{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      bottom:18%;
      font-size:28px;
      letter-spacing:1px;
      color: #fff;
      text-shadow:0 6px 18px rgba(0,0,0,0.6);
      opacity:0;
      transition:opacity 700ms ease 400ms, transform 700ms ease 400ms;
    }

    /* Heart SVG halves - we'll animate them to "open" */
    svg.heart-svg{width:100%;height:100%; display:block;}
    .heart-half{
      transform-origin:50% 50%;
      transition: transform 900ms cubic-bezier(.2,.9,.2,1), filter 300ms;
      filter: drop-shadow(0 6px 20px rgba(0,0,0,0.6));
    }

    /* initial closed positions */
    .heart-left { transform-origin: 65% 30%; }
    .heart-right { transform-origin: 35% 30%; }

    /* when heart open */
    .heart-open .heart-left { transform: rotate(-25deg) translate(-6px,-8px); }
    .heart-open .heart-right { transform: rotate(25deg) translate(6px,-8px); }
    .heart-open .heart-content { opacity:1; transform:translate(-50%,-50%) scale(1); }
    .heart-open .message { opacity:1; transform:translateX(-50%) translateY(0); }

    /* lock group */
    .lock {
      position:absolute;
      width:92px;
      height:92px;
      left:50%;
      top:34%;
      transform:translateX(-50%);
      z-index:40;
      pointer-events:none; /* we interact with key only */
    }

    /* glow when key near */
    .lock .body { transition: fill 220ms ease, filter 220ms ease; }
    .lock.near .body { filter: drop-shadow(0 0 18px var(--glow)); }
    .lock.near .shackle { filter:drop-shadow(0 0 18px var(--glow)); }

    /* locked vs opened visuals */
    .lock.open .body { fill:#2f2f2f; }
    .lock .shackle {
      transform-origin: 50% 75%;
      transition: transform 700ms cubic-bezier(.2,.9,.2,1);
    }
    .lock.open .shackle { transform: rotate(-45deg) translateY(-6px) translateX(-2px); }

    /* the key */
    .key {
      width:160px;
      height:120px;
      position:absolute;
      left:50%;
      bottom:28px;
      transform:translateX(-50%) translateY(0);
      z-index:80;
      touch-action:none;
      cursor:grab;
    }
    .key.dragging{ cursor:grabbing; }
    .key svg{ width:100%; height:100%; display:block; pointer-events:none; }

    .key.inserted{
      transition: transform 600ms cubic-bezier(.2,.9,.2,1);
      z-index:90;
      pointer-events:none;
    }
    /* animate key turning - rotate with transform-origin set inline in JS */
    .key.turning { transition: transform 900ms cubic-bezier(.2,.9,.2,1); }

    /* tiny hint text */
    .hint{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      bottom:6px;
      color:rgba(255,255,255,0.65);
      font-size:13px;
      letter-spacing:0.6px;
    }

    /* small smoke / sparkle for shine */
    .sparkle{
      position:absolute;
      left:50%;
      top:22%;
      width:20px;
      height:20px;
      margin-left:-10px;
      opacity:0;
      transform:translateY(-10px) scale(0.8);
      transition:opacity 220ms, transform 300ms;
      z-index:60;
      pointer-events:none;
    }
    .lock.near ~ .sparkle{ opacity:1; transform:translateY(0) scale(1); filter:drop-shadow(0 0 10px var(--glow)); }

    /* small responsive tweaks */
    @media (max-width:520px){
      .stage{height:86vh;}
      .shrine{width:300px;height:300px;}
      .key{width:140px;height:100px;}
    }
  </style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="shrine">
      <div class="heart-wrap" id="heartWrap" aria-hidden="false">
        <!-- heart SVG with left and right halves -->
        <svg class="heart-svg" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
          <defs>
            <linearGradient id="g1" x1="0" x2="1" y1="0" y2="1">
              <stop offset="0" stop-color="#ff9bb7"/>
              <stop offset="1" stop-color="#ff5d8f"/>
            </linearGradient>
            <filter id="softglow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="6" result="b"/>
              <feBlend in="SourceGraphic" in2="b"/>
            </filter>
          </defs>

          <!-- Left half -->
          <g class="heart-half heart-left" id="heartLeft" transform="">
            <path d="M100 34
                     C80 10, 32 14, 30 58
                     C28 100, 85 135, 100 153
                     Z"
                  fill="url(#g1)" stroke="rgba(0,0,0,0.08)" stroke-width="1.2" />
          </g>

          <!-- Right half -->
          <g class="heart-half heart-right" id="heartRight">
            <path d="M100 34
                     C120 10, 168 14, 170 58
                     C172 100, 115 135, 100 153
                     Z"
                  fill="url(#g1)" stroke="rgba(0,0,0,0.08)" stroke-width="1.2" />
          </g>

        </svg>

        <!-- lock sits on top of heart center -->
        <div class="lock" id="lock" role="img" aria-label="locked heart">
          <svg viewBox="0 0 120 120" width="100%" height="100%" aria-hidden="true">
            <!-- shackle -->
            <g class="shackle" id="shackle" transform="translate(0,0)">
              <path d="M30 50
                       C30 26, 50 10, 60 10
                       C70 10, 90 26, 90 50
                       L90 60 L84 60 L84 50
                       C84 34, 70 22, 60 22
                       C50 22, 36 34, 36 50 L36 60 L30 60 Z"
                    fill="#dcdcdc" stroke="#c7c7c7" stroke-width="1"/>
            </g>

            <!-- lock body -->
            <g transform="translate(12,48)">
              <rect class="body" id="lockBody" x="0" y="8" width="96" height="64" rx="10" ry="10" fill="#1f1f1f" stroke="#2b2b2b" />
              <!-- key-slot -->
              <rect x="40" y="28" width="16" height="10" rx="2" fill="#111" />
            </g>
          </svg>
        </div>

        <!-- revealed content inside heart (hidden until open) -->
        <div class="heart-content" id="heartContent" role="region" aria-hidden="true">
          <!-- sample image (replace with your image) -->
          <img src="https://picsum.photos/520/360?blur=1" alt="valentine image" id="revealImage">
        </div>

        <div class="message" id="message">will u be my valentine</div>
      </div>
    </div>

    <!-- sparkle indicator -->
    <div class="sparkle" id="sparkle" aria-hidden="true">
      <svg viewBox="0 0 24 24" width="100%" height="100%">
        <path d="M12 2 L13.5 9 L21 12 L13.5 15 L12 22 L10.5 15 L3 12 L10.5 9 Z" fill="#ffe7f0" opacity="0.95"/>
      </svg>
    </div>

    <!-- Draggable key -->
    <div class="key" id="key" role="button" aria-label="drag key to unlock">
      <svg viewBox="0 0 240 180" preserveAspectRatio="xMinYMin meet" aria-hidden="true">
        <!-- key head -->
        <g id="keyHead">
          <circle cx="56" cy="56" r="28" fill="#ffd76b" stroke="#b8862b" stroke-width="3" />
          <circle cx="56" cy="56" r="12" fill="#fff7ea" />
        </g>
        <!-- shaft -->
        <rect x="80" y="48" width="100" height="16" rx="6" fill="#ffd76b" stroke="#b8862b" stroke-width="3"/>
        <!-- teeth -->
        <rect x="176" y="46" width="12" height="8" fill="#b8862b"/>
        <rect x="176" y="60" width="12" height="8" fill="#b8862b"/>
      </svg>
    </div>

    <div class="hint">Drag the key to the lock</div>

    <!-- audio: place song.mp3 in same folder or edit the src -->
    <audio id="song" src="song.mp3" preload="auto"></audio>
  </div>

  <script>
    /* Interaction script:
       - Drag the key (pointer events)
       - While dragging, check distance to lock center:
         - if within nearThreshold: add 'near' class to lock to make it shine
         - on pointerup: if near and not opened -> snap key to lock, animate turning, open lock, open heart, play audio
    */

    (function(){
      const stage = document.getElementById('stage');
      const key = document.getElementById('key');
      const lock = document.getElementById('lock');
      const heartWrap = document.getElementById('heartWrap');
      const heartLeft = document.getElementById('heartLeft');
      const heartRight = document.getElementById('heartRight');
      const heartContent = document.getElementById('heartContent');
      const message = document.getElementById('message');
      const sparkle = document.getElementById('sparkle');
      const audio = document.getElementById('song');

      let dragging = false;
      let opened = false;
      let offset = {x:0,y:0};
      let start = {x:0,y:0};
      let keyPos = {x:0,y:0};
      let containerRect;
      let near = false;
      const nearThreshold = 72; // px distance threshold to become 'near'
      const insertThreshold = 52; // px threshold to snap-in on release

      // position the key initially
      function resetKey(){
        const rect = stage.getBoundingClientRect();
        const krect = key.getBoundingClientRect();
        // center bottom
        const left = (rect.width - krect.width)/2;
        const top = rect.height - krect.height - 26;
        key.style.transition = 'transform 400ms cubic-bezier(.2,.9,.2,1)';
        key.style.transform = `translate(${left}px, ${top}px)`;
        // store coordinates in keyPos
        keyPos.x = left;
        keyPos.y = top;
        setTimeout(()=> key.style.transition = '', 420);
      }

      // convert page point to container-local coords
      function toLocalPoint(clientX, clientY){
        const r = stage.getBoundingClientRect();
        return { x: clientX - r.left, y: clientY - r.top };
      }

      function getLockCenter(){
        const r = lock.getBoundingClientRect();
        const s = stage.getBoundingClientRect();
        return { x: r.left - s.left + r.width/2, y: r.top - s.top + r.height/2 };
      }

      // compute distance between key center and lock center
      function checkProximity(keyCenter){
        const lockCenter = getLockCenter();
        const dx = keyCenter.x - lockCenter.x;
        const dy = keyCenter.y - lockCenter.y;
        return Math.sqrt(dx*dx + dy*dy);
      }

      // show near glow
      function setNearState(isNear){
        if(isNear && !near){
          lock.classList.add('near');
          near = true;
        }else if(!isNear && near){
          lock.classList.remove('near');
          near = false;
        }
      }

      // Snap key to lock insertion point and play turn animation, open lock, reveal heart and play audio
      function insertAndOpen(){
        if(opened) return;
        opened = true;
        lock.classList.remove('near');
        // compute insertion coords: align key head center with lock key-slot coords
        const lockRect = lock.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const keyRect = key.getBoundingClientRect();

        // approximate slot center inside lock (in stage coords)
        // The slot is roughly at lock's center bottom area; tweak offsets for good alignment
        const slotStageX = lockRect.left - stageRect.left + lockRect.width*0.5;
        const slotStageY = lockRect.top - stageRect.top + lockRect.height*0.63;

        // compute target top-left for key so its head lines up with slot
        // key head cx is near (keyRect.left + keyRect.width * 0.235)
        const headRelX = keyRect.width * 0.235;
        const headRelY = keyRect.height * 0.31;

        const targetX = slotStageX - headRelX;
        const targetY = slotStageY - headRelY;

        // set key into inserted state and snap
        key.classList.add('inserted');
        // set transform with translate to absolute stage coords
        key.style.transition = 'transform 420ms cubic-bezier(.2,.9,.2,1)';
        key.style.transform = `translate(${targetX}px, ${targetY}px)`;
        // prepare rotate origin - we want to rotate the key around the head (approx)
        // We'll wait for the snap to finish then rotate
        key.addEventListener('transitionend', beginTurn, { once: true });

        function beginTurn(){
          // set transform-origin relative to element: headRelX/headRelY
          const originX = headRelX;
          const originY = headRelY;
          key.style.transformOrigin = `${originX}px ${originY}px`;
          // add turning class for smooth rotation
          requestAnimationFrame(()=>{
            key.classList.add('turning');
            // rotate by -110deg (turning)
            key.style.transform = `translate(${targetX}px, ${targetY}px) rotate(-110deg)`;
          });
          // after rotation finishes, mark lock open
          key.addEventListener('transitionend', finishOpen, { once: true });
        }

        function finishOpen(){
          // animate lock opening
          lock.classList.add('open');
          // animate heart opening
          heartWrap.classList.add('heart-open');
          // make aria visible
          heartContent.setAttribute('aria-hidden','false');
          // show message
          message.style.opacity = '1';
          // play audio (only now)
          // Some browsers require an explicit user gesture; the drag should be fine.
          const playPromise = audio.play();
          if(playPromise !== undefined){
            playPromise.then(()=>{/* playing */})
              .catch(err=>{
                // console.warn('Audio could not autoplay:', err);
                // optionally, you could show a small "play" button if required by the browser
              });
          }
        }
      }

      // Pointer handlers
      function onPointerDown(e){
        if(opened) return;
        dragging = true;
        key.classList.add('dragging');
        containerRect = stage.getBoundingClientRect();
        const local = toLocalPoint(e.clientX, e.clientY);

        const keyRect = key.getBoundingClientRect();
        // compute the offset between pointer and key's top-left
        const keyLeft = keyRect.left - containerRect.left;
        const keyTop = keyRect.top - containerRect.top;
        offset.x = local.x - keyLeft;
        offset.y = local.y - keyTop;
        start.x = local.x - keyPos.x;
        start.y = local.y - keyPos.y;

        key.setPointerCapture(e.pointerId);
      }

      function onPointerMove(e){
        if(!dragging || opened) return;
        const local = toLocalPoint(e.clientX, e.clientY);
        // compute new top-left for key limited within stage
        const keyRect = key.getBoundingClientRect();
        const w = keyRect.width;
        const h = keyRect.height;
        let x = local.x - offset.x;
        let y = local.y - offset.y;
        // clamp
        x = Math.max(0, Math.min(stage.clientWidth - w, x));
        y = Math.max(0, Math.min(stage.clientHeight - h, y));
        // set transform
        key.style.transform = `translate(${x}px, ${y}px)`;
        keyPos.x = x;
        keyPos.y = y;

        // compute center of key
        const keyCenter = { x: x + w/2, y: y + h/2 };
        const dist = checkProximity(keyCenter);

        setNearState(dist < nearThreshold);

        // update sparkle position slightly
        if(near){
          const lockCenter = getLockCenter();
          sparkle.style.left = `${lockCenter.x}px`;
          sparkle.style.top = `${lockCenter.y - 60}px`;
        }
      }

      function onPointerUp(e){
        if(!dragging) return;
        dragging = false;
        key.classList.remove('dragging');
        try{ key.releasePointerCapture && key.releasePointerCapture(e.pointerId); }catch(err){}
        // check if near enough to insert
        // compute key center
        const keyRect = key.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const x = keyRect.left - stageRect.left;
        const y = keyRect.top - stageRect.top;
        const w = keyRect.width;
        const h = keyRect.height;
        const keyCenter = { x: x + w/2, y: y + h/2 };
        const dist = checkProximity(keyCenter);
        setNearState(false);
        if(dist < insertThreshold){
          insertAndOpen();
        }else{
          // return to home position smoothly after a small bounce
          resetKey();
        }
      }

      // attach pointer listeners
      key.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      // touch cancel
      window.addEventListener('pointercancel', onPointerUp);

      // initialize positions when ready and on resize
      function init(){
        resetKey();
        // ensure audio is preloaded as much as possible
        audio.load();
      }
      window.addEventListener('resize', resetKey);
      init();

      // Accessibility: allow keyboard "unlock" â€” space/enter when focus on key triggers open (simulated)
      key.setAttribute('tabindex','0');
      key.addEventListener('keydown', (ev)=>{
        if(opened) return;
        if(ev.key === 'Enter' || ev.key === ' '){
          ev.preventDefault();
          // simulate insertion
          insertAndOpen();
        }
      });

    })();
  </script>
</body>
</html>
